{"version":3,"sources":["extension/Core/Shared/Event.ts","reportWebVitals.ts","extension/Interpolation/BezierCurve.ts","extension/Core/Shared/CoreTimer.ts","extension/Core/Shared/Vec2.ts","extension/Core/C2DApplication.ts","extension/Core/DrawUtils/draw.ts","extension/MathTools.ts","extension/Interpolation/Point.ts","GamePlay/Test.ts","Componnet/GamePlay.ts","index.tsx"],"names":["EInputEventType","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","BezierCurve","time","point","length","newPoint","Array","i","np","clone","scale","scaleAndAdd","push","this","Bezier","CoreTimer","callback","id","enabled","callbackData","undefined","countdown","timeout","onlyOnce","vec2","x","y","values","Float32Array","CanvasInputEvent","altKey","ctrlKey","shiftKey","type","MOUSEEVENT","CanvasMouseEvent","canvasPos","button","canvasPosition","localPosition","create","CanvasKeyBoardEvent","key","keyCode","repeat","KEYBOARDEVENT","Canvas2DApplication","canvas","cv","context2D","getContext","height","window","innerHeight","width","innerWidth","fillStyle","_start","_appId","_lastTime","_startTime","_fps","isSupportMouseMove","_isMouseDown","timers","_timerId","addEventListener","cancelAnimationFrame","requestAnimationFrame","step","bind","timeStamp","elapsedMsec","intervalSec","_handleTimers","Update","Render","evt","dispatchMouseDown","_toCanvasMouseEvent","dispatchMouseUp","dispatchMouseMove","dispatchMouseDrag","dispatchKeyPress","_toCanvasKeyBoardEvent","dispatchKeyDown","dispatchKeyUp","event","rect","getBoundingClientRect","console","log","JSON","stringify","clientX","clientY","target","borderLeftWidth","borderTopWidth","paddingLeft","paddingTop","decl","getComputedStyle","strNumber","parseInt","left","top","Error","mousePosition","_viewportToCanvasCoordinate","timer","data","t","found","CanvasAppFactroy","c","fillCircle","context","radius","fillStype","save","beginPath","arc","Math","PI","fill","restore","strokeLine","x0","y0","x1","y1","moveTo","lineTo","stroke","MathTools","numbers","addNumbers","error","getMean","sqrt","value","minv","maxv","clamp","abs","Point","other","scalar","Sqrt","lenSquare","len","distanceSquare","dx","dy","p0","p1","onet","out","PlayGround","bezier","perFrame","direction","progress","drawBackground","drawText","text","color","algin","baseline","font","textAlign","textBaseline","fillText","lineWidth","strokeRect","fillRect","clearRect","gutter","strokeStyle","strokeGrid","pt","GamePlay","app","run","document","getElementById","createInstance","addTimer","a","start","element","className","ReactDOM","render"],"mappings":"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","file":"static/js/main.6c2d10ea.chunk.js","sourcesContent":["import { vec2 } from './Vec2';\r\n/**\r\n * 输入事件的分发和响应\r\n */\r\n\r\n//事件类型枚举\r\nexport enum EInputEventType{\r\n    MOUSEEVENT,\r\n    MOUSEDOWN,\r\n    MOUSEUP,\r\n    MOUSEMOVE,\r\n    MOUSEDRAG,\r\n    KEYBOARDEVENT,\r\n    KEYUP,\r\n    KEYDOWN,\r\n    KEYPRESS\r\n}\r\n\r\nexport class CanvasInputEvent{\r\n    public altKey:boolean;\r\n    public ctrlKey:boolean;\r\n    public shiftKey:boolean;\r\n    //当前事件类型\r\n    public type:EInputEventType;\r\n    public constructor(\r\n        altKey:boolean=false,\r\n        ctrlKey: boolean = false,\r\n        shiftKey: boolean = false,\r\n        type: EInputEventType = EInputEventType.MOUSEEVENT\r\n    ){\r\n        this.altKey = altKey\r\n        this.ctrlKey = ctrlKey\r\n        this.shiftKey = shiftKey\r\n        this.type = type\r\n    }\r\n}\r\n\r\nexport class CanvasMouseEvent extends CanvasInputEvent{\r\n    // button 表示按下鼠标的哪个键 [0: 左键，1: 中键，2: 右键]\r\n    public button:number;\r\n    // 基于canvas坐标系的表示\r\n    public canvasPosition: vec2\r\n    public localPosition: vec2\r\n\r\n    public constructor(\r\n        canvasPos: vec2,\r\n        button: number,\r\n        altKey: boolean = false,\r\n        ctrlKey: boolean = false,\r\n        shiftKey: boolean = false\r\n      ) {\r\n        super(altKey, ctrlKey, shiftKey)\r\n        this.canvasPosition = canvasPos\r\n        this.button = button\r\n\r\n        // 暂时创建一个vec2对象\r\n        this.localPosition = vec2.create()\r\n      }\r\n}\r\n\r\n/**\r\n *键盘事件\r\n *\r\n * @export\r\n * @class CanvasKeyBoardEvent\r\n * @extends {CanvasInputEvent}\r\n */\r\nexport class CanvasKeyBoardEvent extends CanvasInputEvent{\r\n    // 当前按下的ASCII字符\r\n    public key: string\r\n    // 当前按下的ASCII码\r\n    public keyCode: number\r\n    // 当前按下的键是否不停的出发事件\r\n    public repeat: boolean\r\n    public constructor(\r\n      key: string,\r\n      keyCode: number,\r\n      repeat: boolean,\r\n      altKey: boolean = false,\r\n      ctrlKey: boolean = false,\r\n      shiftKey: boolean = false\r\n    ) {\r\n      super(altKey, ctrlKey, shiftKey, EInputEventType.KEYBOARDEVENT)\r\n      this.key = key\r\n      this.keyCode = keyCode\r\n      this.repeat = repeat\r\n    }\r\n  }","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { NonEmptyArray } from '_@baggie_typescript@0.1.7-alpha.1@@baggie/typescript';\r\nimport { Point } from './Point';\r\nexport class BezierCurve{\r\n    constructor(){}\r\n\r\n    /**\r\n     * N阶贝塞尔曲线递归实现\r\n     * @param time 时间[0-1]\r\n     * @param point 控制点集\r\n     */\r\n    public Bezier(time:number,point:Array<Point>):Point{\r\n        if(point.length < 2){\r\n            return point[0];\r\n        }\r\n        var newPoint:Array<Point> = new Array<Point>();\r\n        for(var i=0;i<point.length-1;++i){\r\n            var np:Point=point[i].clone();\r\n            np.scale(1-time);\r\n            np.scaleAndAdd(point[i+1],time);\r\n            newPoint.push(np);\r\n        }\r\n        return this.Bezier(time,newPoint);\r\n    }\r\n}","export type CoreTimerCallback = (id: number, data: any) => void;\r\n\r\n/**\r\n * 计时器\r\n * 1. Application能够同时触发多个计时器\r\n * 2. 每个计时器能以不同帧率重复执行任务\r\n * 3. 每个计时器能够以倒计时方式执行一次任务\r\n * 4. 尽量让内存使用和执行效率达到相对平衡\r\n *\r\n * @export\r\n * @class Timer\r\n */\r\nexport default class CoreTimer {\r\n  // 唯一ID\r\n  public id: number = -1;\r\n  public enabled: boolean = false;\r\n  public callback: CoreTimerCallback;\r\n  public callbackData: any = undefined;\r\n  public countdown: number = 0;\r\n  public timeout: number = 0;\r\n  public onlyOnce: boolean = false;\r\n  constructor(callback: CoreTimerCallback) {\r\n    this.callback = callback;\r\n  }\r\n}\r\n\r\n","export class vec2 {\r\n    public values: Float32Array\r\n    public constructor(x: number = 0, y: number = 0) {\r\n      this.values = new Float32Array([x, y])\r\n    }\r\n    public toString(): string {\r\n      return `[${this.values[0]},${this.values[1]}]`\r\n    }\r\n    public get x(): number {\r\n      return this.values[0]\r\n    }\r\n    public get y(): number {\r\n      return this.values[1]\r\n    }\r\n    public set x(x: number) {\r\n      this.values[0] = x\r\n    }\r\n    public set y(y: number) {\r\n      this.values[0] = y\r\n    }\r\n  \r\n    // 静态方法\r\n    public static create(x: number = 0, y: number = 0): vec2 {\r\n      return new vec2(x, y)\r\n    }\r\n  }","\r\nimport CoreTimer, { CoreTimerCallback } from \"./Shared/CoreTimer\";\r\nimport { CanvasKeyBoardEvent, CanvasMouseEvent } from \"./Shared/Event\";\r\nimport { vec2 } from \"./Shared/Vec2\";\r\n\r\n\r\ninterface EventListenerObject{\r\n    handleEvent(evt:Event):void;\r\n}\r\n/**\r\n * 全局生命周期\r\n * https://blog.csdn.net/weixin_34310127/article/details/91444405\r\n */\r\nexport class C2DApplication implements EventListenerObject{\r\n    protected _start:boolean =false;\r\n    protected _appId:number = 1;\r\n    protected _lastTime!:number;\r\n    protected _startTime!:number;\r\n    private _fps:number = 0;\r\n    public canvas :HTMLCanvasElement;\r\n\r\n    //为mouseMove事件提供变量开关\r\n    public isSupportMouseMove:boolean;\r\n    protected _isMouseDown:boolean;\r\n\r\n    //计时器功能\r\n    public timers:CoreTimer[] = []\r\n    //Timer id 从0 开始,负数为无效ID\r\n    private _timerId:number = -1;\r\n\r\n    public constructor(canvas:HTMLCanvasElement){\r\n        this.canvas=canvas;\r\n        //canvas 监听鼠标事件\r\n        this.canvas.addEventListener('mousedown', this, false)\r\n        this.canvas.addEventListener('mouseup', this, false)\r\n        this.canvas.addEventListener('mousemove', this, false)\r\n\r\n        window.addEventListener('keydown', this, false)\r\n        window.addEventListener('keyup', this, false)\r\n        window.addEventListener('keypress', this, false)\r\n        //Window监听键盘事件\r\n\r\n        //默认不支持move\r\n        this.isSupportMouseMove=false;\r\n        //默认不支持按下鼠标\r\n        this._isMouseDown=false;\r\n    }\r\n\r\n    public stop(){\r\n        if(this._start){\r\n            cancelAnimationFrame(this._appId);\r\n            this._appId=-1;\r\n            this._lastTime=-1;\r\n            this._startTime=-1;\r\n            this._start=false;\r\n        }\r\n    }\r\n\r\n    public isRunning():boolean{\r\n        return this._start;\r\n    }\r\n\r\n    public get fps():number{\r\n        return this._fps;\r\n    }\r\n\r\n    public start():void{\r\n        if(!this._start){\r\n            this._start=true;\r\n            this._appId=-1;\r\n            this._lastTime=-1;\r\n            this._startTime=-1;\r\n            this._appId=requestAnimationFrame(this.step.bind(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 基于时间的重绘和更新\r\n     * @param timeStamp 时间戳\r\n     */\r\n    protected step(timeStamp:number):void{\r\n        if(this._startTime===-1) this._startTime=timeStamp;\r\n        if(this._lastTime===-1)this._lastTime=timeStamp;\r\n\r\n        //计算当前时间距离第一次时间的差值\r\n        let elapsedMsec:number = timeStamp - this._startTime;\r\n        //计算当前时间距离上一次时间点的差值\r\n        let intervalSec:number =timeStamp-this._lastTime;\r\n        //计算fps\r\n        if(intervalSec!==0){\r\n            this._fps = 1000/intervalSec;\r\n        }\r\n        //将intervalSec化为秒\r\n        intervalSec/=1000;\r\n        this._lastTime=timeStamp;\r\n\r\n\r\n        this._handleTimers(intervalSec);\r\n\r\n        //this.FixedUpdate();\r\n        //先更新\r\n        this.Update(elapsedMsec,intervalSec);\r\n        //再渲染\r\n        this.Render();\r\n        this._appId = requestAnimationFrame(\r\n            (elapsedMsec:number):void=>{\r\n                this.step(elapsedMsec);\r\n            }\r\n        )\r\n    }\r\n    //protected FixedUpdate():void{}\r\n    //更新,子类重写\r\n    /**\r\n     * Update\r\n     * @param elapsedMsec 距离第一次\r\n     * @param intervalSec 距离上一次\r\n     */\r\n    protected Update(elapsedMsec:number,intervalSec:number):void{}\r\n    //渲染,子类覆写\r\n    protected Render():void{}\r\n\r\n//#region 分发事件\r\n    // 分发事件\r\n    public handleEvent(evt: Event): void {\r\n        switch (evt.type) {\r\n        case 'mousedown':\r\n            this._isMouseDown = true\r\n            this.dispatchMouseDown(this._toCanvasMouseEvent(evt))\r\n            break\r\n        case 'mouseup':\r\n            this._isMouseDown = false\r\n            this.dispatchMouseUp(this._toCanvasMouseEvent(evt))\r\n            break\r\n        case 'mousemove':\r\n            // 如果支持move，则分发事件\r\n            if (this.isSupportMouseMove) {\r\n            this.dispatchMouseMove(this._toCanvasMouseEvent(evt))\r\n            }\r\n            // 如果按下一个键拖动，出发drag事件\r\n            if (this._isMouseDown) {\r\n            this.dispatchMouseDrag(this._toCanvasMouseEvent(evt))\r\n            }\r\n            break\r\n        case 'keypress':\r\n            this.dispatchKeyPress(this._toCanvasKeyBoardEvent(evt))\r\n            break\r\n        case 'keydown':\r\n            this.dispatchKeyDown(this._toCanvasKeyBoardEvent(evt))\r\n            break\r\n        case 'keyUp':\r\n            this.dispatchKeyUp(this._toCanvasKeyBoardEvent(evt))\r\n            break\r\n        default:\r\n            break\r\n        }\r\n    }\r\n\r\n    // 具体事件处理方法，子类覆写\r\n    protected dispatchMouseDown(evt: CanvasMouseEvent) { }\r\n    protected dispatchMouseUp(evt: CanvasMouseEvent) { }\r\n    protected dispatchMouseMove(evt: CanvasMouseEvent) { }\r\n    protected dispatchMouseDrag(evt: CanvasMouseEvent) { }\r\n    protected dispatchKeyPress(evt: CanvasKeyBoardEvent) { }\r\n    protected dispatchKeyDown(evt: CanvasKeyBoardEvent) { }\r\n    protected dispatchKeyUp(evt: CanvasKeyBoardEvent) { }\r\n\r\n\r\n    /**\r\n    * 将鼠标指针位置转换为基于canvas元素的偏移表示\r\n    * 即相对于viewpoint的点变换到相对于canvas表示的点\r\n    * 本类私有可用，鼠标事件发生时调用\r\n     * @param event \r\n     */\r\n    private _viewportToCanvasCoordinate(event:MouseEvent):vec2{\r\n        if (this.canvas) {\r\n            let rect: ClientRect = this.canvas.getBoundingClientRect()\r\n            // 测试mousedown\r\n            if (event.type === 'mousedown') {\r\n              console.log(`boundingClientRect: ${JSON.stringify(rect)},clientX: ${event.clientX}, clientY: ${event.clientY}`)\r\n            }\r\n            if (event.target) {\r\n              let borderLeftWidth: number = 0\r\n              let borderTopWidth: number = 0\r\n              let paddingLeft: number = 0\r\n              let paddingTop: number = 0\r\n              let decl: CSSStyleDeclaration = window.getComputedStyle(event.target as HTMLElement)\r\n      \r\n              // borderLeftWidth\r\n              let strNumber: string | null = decl.borderLeftWidth\r\n              if (strNumber !== null) {\r\n                borderLeftWidth = parseInt(strNumber, 10)\r\n              }\r\n              // borderTopWidth\r\n              strNumber = decl.borderTopWidth\r\n              if (strNumber !== null) {\r\n                borderTopWidth = parseInt(strNumber, 10)\r\n              }\r\n              // paddingLeft\r\n              strNumber = decl.paddingLeft\r\n              if (strNumber !== null) {\r\n                paddingLeft = parseInt(strNumber, 10)\r\n              }\r\n              // paddingTop\r\n              strNumber = decl.paddingTop\r\n              if (strNumber !== null) {\r\n                paddingTop = parseInt(strNumber, 10)\r\n              }\r\n      \r\n              let x: number = event.clientX - rect.left - borderLeftWidth - paddingLeft\r\n              let y: number = event.clientY - rect.top - borderTopWidth - paddingTop\r\n              return vec2.create(x, y)\r\n            }else {\r\n                throw new Error('canvas is null.');\r\n            }\r\n        } else {\r\n            throw new Error('canvas is null.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 将DOM EVENT转换为自己定义的CanvasMouseEvent\r\n     *\r\n     * @private\r\n     * @param {Event} evt\r\n     * @returns {CanvasMouseEvent}\r\n     * @memberof Application\r\n     */\r\n    private _toCanvasMouseEvent(evt: Event): CanvasMouseEvent {\r\n        let event: MouseEvent = evt as MouseEvent\r\n        let mousePosition: vec2 = this._viewportToCanvasCoordinate(event)\r\n        let canvasMouseEvent: CanvasMouseEvent\r\n        = new CanvasMouseEvent(\r\n            mousePosition,\r\n            event.button,\r\n            event.altKey,\r\n            event.ctrlKey,\r\n            event.shiftKey\r\n        )\r\n        return canvasMouseEvent\r\n    }\r\n    /**\r\n     * 将DOM EVENT转化为自己定义的CanvasKeyBoardEvent\r\n     *\r\n     * @private\r\n     * @param {Event} evt\r\n     * @returns {CanvasKeyBoardEvent}\r\n     * @memberof Application\r\n     */\r\n    private _toCanvasKeyBoardEvent(evt: Event): CanvasKeyBoardEvent {\r\n        let event: KeyboardEvent = evt as KeyboardEvent\r\n        let canvasKeyBoardEvent: CanvasKeyBoardEvent\r\n        = new CanvasKeyBoardEvent(\r\n            event.key,\r\n            event.keyCode,\r\n            event.repeat,\r\n            event.altKey,\r\n            event.ctrlKey,\r\n            event.shiftKey\r\n        )\r\n        return canvasKeyBoardEvent\r\n    }\r\n//#endregion\r\n\r\n\r\n//#region 定时器相关\r\n    /**\r\n     * 处理定时器函数,update函数中调用\r\n     * @param intervalSec\r\n     */\r\n    private _handleTimers(intervalSec:number):void{\r\n        console.log(\"定时器\");\r\n        if(this.timers.length <= 0) return;\r\n        //遍历timers,查找出enabled为true的timer\r\n        //countdown不断递减,小于等于0时执行一次callback\r\n        for(let i =0;i<this.timers.length;++i){\r\n            let timer:CoreTimer =this.timers[i];\r\n            if(timer.enabled===false)continue;\r\n            timer.countdown -= intervalSec;\r\n\r\n            if(timer.countdown<=0){\r\n                timer.callback(timer.id,timer.callbackData);\r\n                if(timer.onlyOnce === false){\r\n                    timer.countdown=timer.timeout;\r\n                }else{\r\n                    timer.enabled=false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 增加定时器，如果有存在enabled为false的定时器\r\n     * 则直接取出来而不是new 一个\r\n     *\r\n     * @param {TimerCallback} callback\r\n     * @param {number} [timeout=1]\r\n     * @param {boolean} [onlyOnce=false]\r\n     * @param {*} [data=undefined]\r\n     * @returns {number}\r\n     * @memberof Application\r\n     */\r\n    public addTimer(\r\n        callback: CoreTimerCallback,\r\n        timeout: number = 1,\r\n        onlyOnce: boolean = false,\r\n        data: any = undefined\r\n    ): number {\r\n        let timer: CoreTimer\r\n        for (let i = 0; i < this.timers.length; i++) {\r\n        let t = this.timers[i]\r\n        if (t.enabled === false) {\r\n            t.callback = callback\r\n            t.callbackData = data\r\n            t.timeout = timeout\r\n            t.countdown = timeout\r\n            t.enabled = true\r\n            t.onlyOnce = onlyOnce\r\n            return t.id\r\n        }\r\n        }\r\n        timer = new CoreTimer(callback)\r\n        timer.callbackData = data\r\n        timer.timeout = timeout\r\n        timer.countdown = timeout\r\n        timer.enabled = true\r\n        timer.onlyOnce = onlyOnce\r\n        timer.id = ++this._timerId\r\n        this.timers.push(timer)\r\n\r\n        return timer.id\r\n    }\r\n\r\n        /**\r\n     * 移除定时器 【逻辑删除，设置enable状态】\r\n     *\r\n     * @param {number} id\r\n     * @returns {boolean}\r\n     * @memberof Application\r\n     */\r\n    public removeTimer(id: number): boolean {\r\n        let found: boolean = false\r\n        for (let i = 0; i < this.timers.length; i++) {\r\n            if (this.timers[i]['id'] === id) {\r\n                this.timers[i]['enabled'] = false\r\n                found = true\r\n                break\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n//#endregion\r\n\r\n}\r\n\r\n\r\nexport class Canvas2DApplication extends C2DApplication {\r\n    protected context2D: CanvasRenderingContext2D | null\r\n\r\n    constructor(canvas: HTMLCanvasElement) {\r\n      let cv = <HTMLCanvasElement>canvas;\r\n      super(cv);\r\n      this.context2D = this.canvas.getContext('2d');\r\n      let H = this.canvas.height = window.innerHeight / 4 *3;\r\n      let W = this.canvas.width = window.innerWidth / 4 * 3;\r\n\r\n      if(this.context2D!=null)\r\n        this.context2D.fillStyle = \"#53B7F6\";\r\n    }\r\n}\r\n\r\nexport class CanvasAppFactroy{\r\n    public static createInstance<T extends Canvas2DApplication>(c:new(cv:HTMLCanvasElement)=>T,canvas:HTMLCanvasElement):T{\r\n        return new c(canvas);\r\n    }\r\n}","// 绘制实心点或圆\r\nexport const fillCircle = (\r\n  context: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  radius: number,\r\n  fillStype: string | CanvasGradient | CanvasPattern = \"red\"\r\n): void => {\r\n  if (context !== null) {\r\n    context.save();\r\n    context.fillStyle = fillStype;\r\n    context.beginPath();\r\n    context.arc(x, y, radius, 0, Math.PI * 2);\r\n    context.fill();\r\n    context.restore();\r\n  }\r\n};\r\n\r\n// 绘制实心文字\r\ntype TextAlign = \"start\" | \"left\" | \"center\" | \"right\" | \"end\";\r\ntype TextBaseline = \"alphabetic\" | \"hanging\" | \"top\" | \"middle\" | \"bottom\";\r\nexport const fillText = (\r\n  context: CanvasRenderingContext2D,\r\n  text: string,\r\n  x: number,\r\n  y: number,\r\n  color: string = \"#fff\",\r\n  algin: TextAlign = \"left\",\r\n  baseline: TextBaseline = \"middle\",\r\n  font: string = \"14px sans-serif\"\r\n): void => {\r\n  if (context !== null) {\r\n    context.save();\r\n    context.textAlign = algin;\r\n    context.textBaseline = baseline;\r\n    context.font = font;\r\n    context.fillStyle = color;\r\n    context.fillText(text, x, y);\r\n    context.restore();\r\n  }\r\n};\r\n\r\n// 绘制线段\r\nexport const strokeLine = (\r\n  context: CanvasRenderingContext2D,\r\n  x0: number,\r\n  y0: number,\r\n  x1: number,\r\n  y1: number\r\n): void => {\r\n  if (context !== null) {\r\n    context.beginPath();\r\n    context.moveTo(x0, y0);\r\n    context.lineTo(x1, y1);\r\n    context.stroke();\r\n  }\r\n};\r\n\r\n// 绘制坐标轴\r\nexport const strokeCoord = (\r\n  context: CanvasRenderingContext2D,\r\n  originX: number,\r\n  originY: number,\r\n  width: number,\r\n  height: number\r\n): void => {\r\n  if (context !== null) {\r\n    context.save();\r\n    // x 轴\r\n    context.strokeStyle = \"red\";\r\n    strokeLine(context, originX, originY, originX + width, originY);\r\n    // y 轴\r\n    context.strokeStyle = \"blue\";\r\n    strokeLine(context, originX, originY, originX, originY + height);\r\n    context.restore();\r\n  }\r\n};\r\n\r\n// 绘制网格\r\nexport const strokeGrid = (\r\n  context: CanvasRenderingContext2D,\r\n  color: string,\r\n  gutter: number = 10\r\n): void => {\r\n  if (context !== null) {\r\n    context.save();\r\n    context.strokeStyle = color;\r\n    context.lineWidth = 0.5;\r\n    // 从左向右画竖线\r\n    for (let i: number = gutter + 0.5; i < context.canvas.width; i += gutter) {\r\n      strokeLine(context, i, 0, i, context.canvas.height);\r\n    }\r\n    // 从上向下画竖线\r\n    for (let i: number = gutter + 0.5; i < context.canvas.height; i += gutter) {\r\n      strokeLine(context, 0, i, context.canvas.width, i);\r\n    }\r\n    context.restore();\r\n  }\r\n};\r\n","//https://bag-of-tricks.github.io/modules/math.html\r\n\r\nimport { addNumbers, clamp, getMean } from \"@baggie/math\";\r\nimport { NonEmptyArray } from \"_@baggie_typescript@0.1.7-alpha.1@@baggie/typescript\";\r\n\r\nexport class MathTools{\r\n    constructor(){}\r\n\r\n    //将一个数字数组加和\r\n    public static Sum(numbers: NonEmptyArray<number>):number{\r\n        try{\r\n            return addNumbers(numbers);\r\n        }catch(error){\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    //获取平均值\r\n    public static GetAverage(numbers:NonEmptyArray<number>):number{\r\n        try{\r\n            return getMean(numbers);\r\n        }catch(error){\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public static Sqrt(x:number):number{\r\n        return Math.sqrt(x);\r\n    }\r\n\r\n    public static Clamp(value:number,minv:number,maxv:number){\r\n        return clamp(value,minv,maxv);\r\n    }\r\n\r\n    public static Absf(value:number):number{\r\n        return Math.abs(value);\r\n    }\r\n}","import { MathTools } from './../MathTools';\r\n\r\nexport interface PointLike{\r\n    x:number,\r\n    y:number\r\n}\r\n\r\n//插值计算中的笛卡尔下的点\r\nexport class Point{\r\n    constructor(x?:number,y?:number){\r\n        this.x=x || 0;\r\n        this.y=y || 0;\r\n    }\r\n    public x:number;\r\n    public y:number;\r\n\r\n    public clone(){\r\n        return new Point(this.x,this.y);\r\n    }\r\n\r\n    public set(x:number,y:number){\r\n        this.x=x;\r\n        this.y=y;\r\n    }\r\n\r\n    public equal(other:Point){\r\n        return other.x==this.x && other.y==this.y;\r\n    }\r\n\r\n    public add(other:Point){\r\n        this.x+=other.x;\r\n        this.y+=other.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * 数乘\r\n    */\r\n    public scale(scalar:number){\r\n        this.x*=scalar;\r\n        this.y*=scalar;\r\n    }\r\n\r\n    public scaleAndAdd(other:Point,scalar:number){\r\n        this.x += other.x*scalar;\r\n        this.y += other.y*scalar;\r\n    }\r\n\r\n    public sub(other: Point){\r\n        this.x -= other.x;\r\n        this.y -= other.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * 点乘\r\n     * @param other 另外一个点\r\n     */\r\n    public dot(other:Point){\r\n        return this.x*other.x+this.y*other.y;\r\n    }\r\n\r\n    /**\r\n     * 获取到原点的距离\r\n     */\r\n    public len(){\r\n        return MathTools.Sqrt(this.lenSquare());\r\n    }\r\n\r\n    public lenSquare(){\r\n        return this.x*this.x + this.y*this.y;\r\n    }\r\n\r\n    /**\r\n     * 归一化\r\n     */\r\n    public normalize(){\r\n        const len =this.len();\r\n        this.x /=len;\r\n        this.y /=len;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * 到另一个点的距离\r\n     * @param other\r\n     */\r\n    public distance(other:Point):number{\r\n        return MathTools.Sqrt(this.distanceSquare(other));\r\n    }\r\n\r\n    public distanceSquare(other:Point){\r\n        const dx = this.x -other.x;\r\n        const dy = this.y - other.y;\r\n        return dx*dx+dy*dy;\r\n    }\r\n\r\n    public negate(){\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n    }\r\n\r\n    /**\r\n     * 线性插值\r\n     * @param p0 A点\r\n     * @param p1 B点\r\n     * @param t 时间比例\r\n     */\r\n    static lerp(p0:Point,p1:Point,t:number):Point{\r\n        const onet =1-t;\r\n        var out:Point=new Point(0,0);\r\n        out.x = onet * p0.x + t* p1.x;\r\n        out.y = onet * p0.y + t*p1.y;\r\n        return out;\r\n    }\r\n\r\n}","import { MathTools } from './../extension/MathTools';\r\nimport { BezierCurve } from './../extension/Interpolation/BezierCurve';\r\nimport { Canvas2DApplication } from \"../extension/Core/C2DApplication\";\r\nimport {\r\n    fillText,\r\n    strokeGrid,\r\n    fillCircle,\r\n    strokeCoord,\r\n} from \"../extension/Core/DrawUtils/draw\";\r\nimport {\r\n    CanvasKeyBoardEvent,\r\n    CanvasMouseEvent,\r\n} from \"../extension/Core/Shared/Event\";\r\nimport { Point } from '../extension/Interpolation/Point';\r\n\r\nexport class PlayGround extends Canvas2DApplication {\r\n    constructor(canvas: HTMLCanvasElement) {\r\n        super(canvas);\r\n        this.bezier=new BezierCurve();\r\n        this.point = new Point(40,40);\r\n        this.perFrame = 2000;\r\n        this.direction = true; //初始正向\r\n        this.progress=0.0;\r\n    }\r\n    private bezier:BezierCurve;\r\n    private point:Point;\r\n    private perFrame:number;\r\n    private direction:boolean;\r\n    private progress:number;\r\n\r\n    protected Render(): void {\r\n        this.drawBackground();\r\n        this.drawText(\"Solvarg\");\r\n    }\r\n\r\n    protected drawText(text: string): void {\r\n        if (this.context2D !== null) {\r\n            let c = this.context2D;\r\n            // 计算cnavas中心坐标\r\n            let centerX: number = c.canvas.width * 0.5;\r\n            let centerY: number = c.canvas.height * 0.5;\r\n\r\n            fillText(\r\n                c,\r\n                text,\r\n                centerX,\r\n                centerY,\r\n                \"#000\",\r\n                \"center\",\r\n                \"middle\",\r\n                \"140px sans-serif\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // 画背景\r\n    protected drawBackground(): void {\r\n        let c = this.context2D;\r\n        if (c !== null) {\r\n            c.lineWidth = 10;\r\n            //为指定矩形描边 如果后两个参数中任何一个为0，则画横线或者竖线,都为0则不绘制\r\n            c.strokeRect(75, 100, 200, 200);\r\n            //填充矩形，如何后两个参数任意一个为0，则不绘制\r\n            c.fillRect(325, 100, 200, 200);\r\n            c.clearRect(0, 0, c.canvas.width, c.canvas.height);\r\n            fillCircle(c, this.point.x, this.point.y, 10, \"green\");\r\n            strokeGrid(c, \"#333\", 15);\r\n            fillCircle(c,200,200,80,'rgb('+(255*this.progress)+','+(255-255*this.progress)+',100)');\r\n            //strokeCoord(c, 0, 0, c.canvas.width, c.canvas.height)\r\n        }\r\n    }\r\n\r\n    protected Update(elapsedMsec:number,intervalSec:number) {\r\n        this.direction = (((elapsedMsec/this.perFrame) & 1)===0);\r\n        this.progress = (elapsedMsec%this.perFrame)/this.perFrame;\r\n        if(!this.direction){\r\n            this.progress = 1-this.progress;\r\n        }\r\n        var pt:Point=this.bezier.Bezier(this.progress,[\r\n            new Point(0.86, 0),\r\n            new Point(0.07, 1),\r\n            new Point(0.52, 0.52),\r\n            new Point(0.74, 0.32)\r\n        ]);\r\n\r\n        //[40,40] - [180,120]\r\n        this.point.x = pt.x*800 + 60;\r\n        this.point.y = pt.y*600 + 60;\r\n    }\r\n\r\n    // 鼠标\r\n    protected dispatchMouseDown(evt: CanvasMouseEvent) {\r\n        console.log(\"鼠标按下\", evt);\r\n    }\r\n\r\n    // 按键\r\n    protected dispatchKeyPress(evt: CanvasKeyBoardEvent) {\r\n        console.log(\"按键\", evt);\r\n    }\r\n}\r\n","import { Type } from \"typescript\";\r\nimport { PlayGround } from \"../GamePlay/Test\";\r\nimport { Canvas2DApplication, CanvasAppFactroy } from \"./../extension/Core/C2DApplication\";\r\nclass GamePlay{\r\n  constructor() {\r\n    this.run.bind(this);\r\n    this.canvas = document.getElementById(\r\n        \"canvas\"\r\n    ) as HTMLCanvasElement;\r\n  }\r\n\r\n  private canvas: HTMLCanvasElement;\r\n  private app?: Canvas2DApplication;\r\n\r\n  public run(): void {\r\n    // 调用\r\n    // 测试定时器\r\n    if (this.canvas !== null) {\r\n        this.app = CanvasAppFactroy.createInstance(PlayGround,this.canvas);\r\n        this.app.addTimer(\r\n            (id,data)=>{\r\n                console.log(data);\r\n            },\r\n            3,\r\n            false,\r\n            {a:1}\r\n        );\r\n        this.app.start();\r\n    }\r\n  }\r\n}\r\n\r\nexport default GamePlay;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport GamePlay from \"./Componnet/GamePlay\";\n\nconst element = (\n  <div className=\"playground\">\n    <canvas id=\"canvas\"></canvas>\n  </div>\n);\nReactDOM.render(element, document.getElementById(\"root\"));\n\nvar gamePlay:GamePlay=new GamePlay();\ngamePlay.run();\n\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}